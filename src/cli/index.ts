#!/usr/bin/env node

import { program } from "commander";
import { jsonSchemaToZod } from "json-schema-to-zod";
import { writeFile, readFile } from "node:fs/promises";
import { createSchema } from "./schema.js";
import { DualshockConfig } from "./config.js";

export { DualshockConfig };

program
	.command("schema")
	.option("--config <path>")
	.description(
		"Generate Dualshock RPC Schema to create client's type definitions (or client libs)",
	)
	// TODO: add beautiful error message - check if the file exists
	.action(async ({ config: configFile = "dualshock.config.ts" }) => {
		const configFilePath = getCwdPath(configFile);

		const { default: configModule } = await import(configFilePath);

		const config = DualshockConfig.parse(configModule);

		const schema = createSchema(config);

		const serviceSchema = JSON.stringify(schema, null, 2);

		const outputPath = getCwdPath(config.output);
		await writeFile(outputPath, serviceSchema);

		process.exit(0);
	});

program
	.command("typescript")
	.option("--schema <path>")
	.option("--output <path>")
	.description("Generate TypeScript types from the provided JSON Schema")
	.action(
		async ({
			schema: schemaFile = `${process.cwd()}/dualshock.schema.json`,
			output: outputFile = `${process.cwd()}/src/dualshock.gen.ts`,
			rpcTypeName = "DualshockInvokables",
			eventTypeName = "DualshockEvents",
		}) => {
			// TODO: Should we call resolveRefs here?
			// import { z } from "zod"
			// import { resolveRefs } from "json-refs"
			// import { format } from "prettier"
			// import jsonSchemaToZod from "json-schema-to-zod"

			// async function example(jsonSchema: any) {
			//   const { resolved }= await resolveRefs(jsonSchema)
			//   const code = jsonSchemaToZod(resolved)
			//   const formatted = await format(code, { parser: "typescript" })

			//   return formatted
			// }

			const { $schemaVersion, ...schema } = JSON.parse(
				await readFile(schemaFile, "utf8"),
			);

			if ($schemaVersion !== "dualshock:1") {
				throw new Error("Invalid schema version");
			}

			const contents = [
				"// This file was automatically generated by the @ptah/dualshock package",
				"// DO NOT EDIT",
				"//",
				`// Schema: ${schemaFile}`,
				`// Schema Version: ${$schemaVersion}`,
				`// RPC Type Name: ${rpcTypeName}`,
				`// Event Type Name: ${eventTypeName}`,
				`// Output: ${outputFile}`,
				"",
			];

			contents.push("import { z, type ZodType } from 'zod';");
			contents.push("");

			console.log(`export const ${eventTypeName} = {`);
			for (const [event, { payload }] of Object.entries<any>(schema.events)) {
				contents.push(`  "${event}": {`);
				contents.push(
					`    payload: ${jsonSchemaToZod(payload).replace(
						/\.strict\(\)/g,
						"",
					)},`,
				);
				contents.push("  },");
			}
			contents.push("} as const;");
			contents.push("");

			contents.push(`export const ${rpcTypeName} = {`);
			for (const [rpc, { args, returns }] of Object.entries<any>(schema)) {
				contents.push(`  "${rpc}": {`);
				contents.push(
					`    args: ${
						args
							? jsonSchemaToZod(args).replace(/\.strict\(\)/g, "")
							: "undefined"
					},`,
				);
				contents.push(
					`    returns: ${
						returns
							? jsonSchemaToZod(returns).replace(/\.strict\(\)/g, "")
							: "undefined"
					},`,
				);
				contents.push("  },");
			}
			contents.push("} as const;");

			contents.push("");

			contents.push(`
				type TInvokables = typeof ${rpcTypeName};
				type TRpcName = keyof TInvokables;

				export type ${rpcTypeName} = {
					[key in TRpcName]: {
						args: z.infer<TInvokables[key]["args"]>;
						returns: TInvokables[key]["returns"] extends ZodType<infer T> ? T : undefined;
					}
				}
			`);

			await writeFile(outputFile, `${contents.join("\n")}\n`, {
				encoding: "utf8",
			});

			console.log(`Generated: ${outputFile}`);

			process.exit(0);
		},
	);

program.parse();

function getCwdPath(path: string) {
	const slashedPath = path.startsWith("/") ? path : `/${path}`;

	return process.cwd() + slashedPath;
}
