#!/usr/bin/env node

import { program } from "commander";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import { jsonSchemaToZod } from "json-schema-to-zod";
import { writeFile, readFile } from "node:fs/promises";
import type { TRpc } from "../RpcDefinition.js";

export type DualshockConfig = {
	registry: Record<string, TRpc<any, any, any>>;
};

const dualshockConfig = z.object({
	// TODO: convert RpcDefinition into zod and use it's schema here
	registry: z.record(z.any()),
	output: z.string().default(`${process.cwd()}/dualshock.schema.json`),
});

program
	.command("schema")
	.option("--config <path>")
	.description(
		"Generate Dualshock RPC Schema to create client's type definitions (or client libs)",
	)
	// TODO: add beautiful error message - check if the file exists
	.action(
		async ({ config: configFile = `${process.cwd()}/dualshock.config.ts` }) => {
			const { default: configModule } = await import(configFile);

			const config = dualshockConfig.parse(configModule);

			const schema = Object.entries(config.registry).reduce(
				(acc, [key, value]: [string, any]) => {
					const rpcSchema: any = {};

					if (value.args) {
						rpcSchema.args = zodToJsonSchema(value.args);
					}
					if (value.returns) {
						rpcSchema.returns = zodToJsonSchema(value.returns);
					}

					acc[key] = rpcSchema;

					return acc;
				},
				{
					$schemaVersion: "dualshock:1",
				} as any,
			);

			const serviceSchema = JSON.stringify(schema, null, 2);

			await writeFile(config.output, serviceSchema);

			process.exit(0);
		},
	);

program
	.command("typescript")
	.option("--schema <path>")
	.option("--output <path>")
	.option("--const <name>")
	.description("Generate TypeScript types from the provided JSON Schema")
	.action(
		async ({
			schema: schemaFile = `${process.cwd()}/dualshock.schema.json`,
			output: outputFile = `${process.cwd()}/src/dualshock.gen.ts`,
			typeName = "DualshockInvokables",
		}) => {
			// TODO: Should we call resolveRefs here?
			// import { z } from "zod"
			// import { resolveRefs } from "json-refs"
			// import { format } from "prettier"
			// import jsonSchemaToZod from "json-schema-to-zod"

			// async function example(jsonSchema: any) {
			//   const { resolved }= await resolveRefs(jsonSchema)
			//   const code = jsonSchemaToZod(resolved)
			//   const formatted = await format(code, { parser: "typescript" })

			//   return formatted
			// }

			const { $schemaVersion, ...schema } = JSON.parse(
				await readFile(schemaFile, "utf8"),
			);

			if ($schemaVersion !== "dualshock:1") {
				throw new Error("Invalid schema version");
			}

			const contents = [
				"// This file was automatically generated by the @ptah/dualshock package",
				"// DO NOT EDIT",
				"//",
				`// Schema: ${schemaFile}`,
				`// Schema Version: ${$schemaVersion}`,
				`// Type Name: ${typeName}`,
				`// Output: ${outputFile}`,
				"",
			];

			contents.push(
				"import { z, type infer as zInfer, type ZodType } from 'zod';",
			);
			contents.push("");

			contents.push(`export const ${typeName} = {`);
			for (const [rpc, { args, returns }] of Object.entries<any>(schema)) {
				contents.push(`  "${rpc}": {`);
				contents.push(
					`    args: ${
						args
							? jsonSchemaToZod(args).replace(/\.strict\(\)/g, "")
							: "undefined"
					},`,
				);
				contents.push(
					`    returns: ${
						returns
							? jsonSchemaToZod(returns).replace(/\.strict\(\)/g, "")
							: "undefined"
					},`,
				);
				contents.push("  },");
			}
			contents.push("} as const;");

			contents.push("");

			contents.push(`
				type TInvokables = typeof ${typeName};
				type TRpcName = keyof TInvokables;

				export type ${typeName} = {
					[key in TRpcName]: {
						args: zInfer<TInvokables[key]["args"]>;
						returns: TInvokables[key]["returns"] extends ZodType<infer T> ? T : void;
					}
				}
			`);

			await writeFile(outputFile, `${contents.join("\n")}\n`, {
				encoding: "utf8",
			});

			console.log(`Generated: ${outputFile}`);
			process.exit(0);
		},
	);

program.parse();
